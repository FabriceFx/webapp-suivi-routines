/**
 * Point d'entr√©e de l'application Web (Web App).
 * Charge le template HTML et d√©finit les m√©tadonn√©es.
 *
 * @author Fabrice Faucheux
 * @return {HtmlOutput} Le contenu HTML √©valu√©.
 */
function doGet() {
  try {
    return HtmlService.createTemplateFromFile('Index')
      .evaluate()
      .setTitle('App Suivi Routines')
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  } catch (erreur) {
    console.error('Erreur lors du chargement de la Web App :', erreur);
    return HtmlService.createHtmlOutput("Une erreur est survenue lors du chargement de l'application.");
  }
}

// --- PARTIE 1 : SAISIE & GESTION ---

/**
 * Supprime la derni√®re entr√©e enregistr√©e dans l'onglet "Logs".
 *
 * @author Fabrice Faucheux
 * @return {string} Message de confirmation avec la valeur supprim√©e.
 */
function supprimerDerniereEntree() {
  try {
    const feuille = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Logs");
    const derniereLigne = feuille.getLastRow();

    if (derniereLigne > 1) {
      // Optimisation : on ne lit que la cellule n√©cessaire (Nom de la routine, col B) pour le feedback
      const valeurSupprimee = feuille.getRange(derniereLigne, 2).getValue();
      feuille.deleteRow(derniereLigne);
      
      return `üóëÔ∏è Entr√©e '${valeurSupprimee}' supprim√©e.`;
    } else {
      throw new Error("L'historique est vide, aucune suppression possible.");
    }
  } catch (erreur) {
    console.error('Erreur dans supprimerDerniereEntree :', erreur);
    throw new Error(erreur.message);
  }
}

/**
 * Enregistre une routine dans l'onglet "Logs", avec une date et une valeur optionnelle.
 * Fusionne les anciennes logiques de sauvegarde.
 *
 * @author Fabrice Faucheux
 * @param {string} nomRoutine - Le nom de la routine (ex: "Sport").
 * @param {string} [dateIso] - La date au format "YYYY-MM-DD". Si vide, utilise la date du jour.
 * @param {string|number} [valeur] - (Optionnel) La quantit√© ou valeur associ√©e.
 * @return {string} Message de confirmation pour l'interface utilisateur.
 */
function sauvegarderRoutine(nomRoutine, dateIso, valeur) {
  try {
    const feuille = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Logs");
    
    // Gestion de la date : fournie ou instant pr√©sent
    // On fixe l'heure √† midi pour √©viter les probl√®mes de fuseaux horaires sur les dates pures
    let dateLog;
    if (dateIso) {
      dateLog = new Date(dateIso);
      dateLog.setHours(12, 0, 0, 0);
    } else {
      dateLog = new Date();
    }

    // Pr√©paration de la valeur √† stocker (vide si non d√©finie)
    const valeurStockee = (valeur !== undefined && valeur !== null) ? valeur : "";

    // √âcriture : Date (A) | Nom (B) | Valeur (C)
    feuille.appendRow([dateLog, nomRoutine, valeurStockee]);
    
    // Feedback utilisateur
    const messageValeur = valeurStockee ? ` (${valeurStockee})` : "";
    
    // Formatage convivial de la date pour le retour
    const optionsDate = { weekday: 'long', day: 'numeric', month: 'long' };
    const dateLisible = dateLog.toLocaleDateString('fr-FR', optionsDate);

    return `‚úÖ ${nomRoutine}${messageValeur} enregistr√© pour le ${dateLisible} !`;

  } catch (erreur) {
    console.error('Erreur sauvegarderRoutine :', erreur);
    throw new Error(`Erreur lors de la sauvegarde de : ${nomRoutine}`);
  }
}

/**
 * R√©cup√®re la configuration compl√®te (Nom + Unit√©) depuis l'onglet "Config".
 *
 * @author Fabrice Faucheux
 * @return {Object[]} Liste d'objets {nom, unite}.
 */
function recupererListeRoutines() {
  try {
    const feuille = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Config");
    const derniereLigne = feuille.getLastRow();
    
    // S'il n'y a que l'en-t√™te ou moins
    if (derniereLigne < 2) return [];

    // Lecture batch : Colonnes A (Nom), B (Objectif), C (Unit√©)
    const valeurs = feuille.getRange(2, 1, derniereLigne - 1, 3).getValues();

    // Mapping et nettoyage des lignes vides
    return valeurs
      .map(ligne => ({
        nom: ligne[0],
        unite: ligne[2] ? ligne[2].toString() : "" 
      }))
      .filter(r => r.nom !== "");

  } catch (erreur) {
    console.error('Erreur recupererListeRoutines :', erreur);
    throw new Error("Impossible de r√©cup√©rer la liste des routines.");
  }
}

// --- PARTIE 2 : ANALYSE & RAPPORTS ---

/**
 * G√©n√®re les donn√©es pour le rapport mensuel (Heatmap, graphes).
 *
 * @author Fabrice Faucheux
 * @param {number} annee - L'ann√©e cible (ex: 2026).
 * @param {number} mois - Le mois cible (1-12).
 * @return {Object} Objet complexe contenant configuration, donn√©es journali√®res et stats.
 */
function genererRapportMensuel(annee, mois) {
  try {
    const classeur = SpreadsheetApp.getActiveSpreadsheet();
    const logsSheet = classeur.getSheetByName("Logs");
    const configSheet = classeur.getSheetByName("Config");

    // 1. Config : R√©cup√©ration en batch
    let configRoutines = [];
    const lastRowConfig = configSheet.getLastRow();
    if (lastRowConfig > 1) {
      configRoutines = configSheet.getRange(2, 1, lastRowConfig - 1, 3).getValues()
        .map(ligne => ({
          nom: ligne[0],
          objectif: ligne[1] || 0, 
          unite: ligne[2] || ""
        }))
        .filter(r => r.nom !== "");
    }

    // 2. Logs : R√©cup√©ration en batch
    let logs = [];
    const lastRowLogs = logsSheet.getLastRow();
    if (lastRowLogs > 1) {
      logs = logsSheet.getRange(2, 1, lastRowLogs - 1, 3).getValues();
    }

    // 3. Traitement des donn√©es
    const rapport = {};          // Structure: { "Sport": { 1: 10, 5: 5 } } -> jour: valeur
    const statsJournalieres = {}; // Structure: { 1: 3, 2: 0 } -> jour: nombre d'activit√©s
    
    // Initialisation du rapport pour chaque routine configur√©e
    configRoutines.forEach(c => rapport[c.nom] = {});

    const moisIndex = mois - 1; // JS months sont 0-11

    logs.forEach(ligne => {
      const [dateBrute, nom, valeurBrute] = ligne;
      
      // S√©curit√© : on s'assure que c'est un objet Date
      const dateLog = new Date(dateBrute);

      if (dateLog.getFullYear() === annee && dateLog.getMonth() === moisIndex) {
        const jour = dateLog.getDate();
        
        // Si une routine a √©t√© logu√©e mais n'est plus dans la config, on l'initialise quand m√™me
        if (!rapport[nom]) rapport[nom] = {};

        // Calcul de la valeur √† ajouter :
        // Si une valeur quantitative existe, on l'utilise. Sinon (mode check), c'est 1.
        const valAjoutee = (valeurBrute && !isNaN(valeurBrute)) ? Number(valeurBrute) : 1;
        
        // Agr√©gation
        rapport[nom][jour] = (rapport[nom][jour] || 0) + valAjoutee;
        
        // Statistique globale (nombre d'actions par jour, ind√©pendamment de la quantit√©)
        statsJournalieres[jour] = (statsJournalieres[jour] || 0) + 1;
      }
    });

    return {
      routines: configRoutines,
      donnees: rapport,
      statsJournalieres: statsJournalieres,
      joursDansLeMois: new Date(annee, mois, 0).getDate()
    };

  } catch (e) {
    console.error('Erreur critique dans genererRapportMensuel :', e);
    throw new Error("Erreur lors de la g√©n√©ration du rapport.");
  }
}
